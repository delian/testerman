# __METADATA__BEGIN__
# <?xml version="1.0" encoding="utf-8" ?>
# <metadata version="1.0">
# <description>Testerman auto test to pass before any release.</description>
# <prerequisites></prerequisites>
# <parameters>
# <parameter name="PX_UNICODE_STRING" default="Ã§a marche" type="string"><![CDATA[Unicode session variable test. Do not change its value.]]></parameter>
# </parameters>
# </metadata>
# __METADATA__END__
##
# Testerman core feature (TTCN-3 oriented) auto tests.
#
##
 
##
# templates (messages) definitions
##

# None shared between testcases.

##
# Test case definitions
##

class TC_TIMER(TestCase):
	"""
	Basic Timer Management.
	Run two timers, etc.
	"""
	def body(self):
		log("Testerman autotest: timer basic management")
		
		# Let's define a timer
		t = Timer(1.5)
		
		# Start and stop.
		t.start()
		t.stop()
		
		# Restart, timeout
		t.start()
		alt([
			[ t.TIMEOUT,
				lambda: log("timeout correctly received"),
				lambda: setverdict("pass"),
			]
		])
		
		# Multiple timers.
		t1 = Timer(3.0)
		t2 = Timer(1.0)
		t1.start()
		t2.start()
		alt([
			[ t2.TIMEOUT,
				lambda: log("Shortest timeout correctly received"),
				lambda: t1.stop(),
				lambda: setverdict("pass"),
			],
			[ t1.TIMEOUT,
				lambda: log("Sorry, the longuest timeout was received first"),
				lambda: setverdict("fail"),
			]
		])
		
		# "Sleep simulator": this is the TTCN-3 way to create a sleep(2000ms).
		s = Timer(1.0)
		s.start()
		s.timeout()
		
		# running() test
		
		log("Checking running()...")
		if s.running():
			log("Stopped timer seen as running. Test failed.")
			setverdict("fail")
		s.start(1)
		if not s.running():
			log("Started timer not seen as running. Test failed.")
			setverdict("fail")
		s.stop()
		
		log("Checking read()...")
		# Read timer expected accuracy: 50ms
		delta = 0.05
		t1.start(5.0)
		t2.start(1.0)
		t2.timeout()
		# Normally, t1 started 1 second ago
		d = t1.read()
		if abs(1.0 - d) > delta:
			log("Incorrect read timer: got %f, expected 1s" % d)
			setverdict("fail")
		log("Read timer accuracy: %fs" % abs(1.0 - d))
			
		setverdict("pass")
		log("End of testcase reached.")

class TC_SIMPLE_CONNECTION(TestCase):
	"""
	This sample demonstrates simple port communications.
	"""
	def body(self):
		log("Testerman autotest: implicit MTC, simple port communications")
		self.set_description("A description. Overriding the default one.")
		
		# Let's define a PTC
		ptc01 = self.create()
		
		# Let's connect some ports
		p01 = self.mtc['port01']
		p02 = ptc01['port02']
		connect(p01, p02)
		
		# Let's send a message through port 01 and wait for it on port02
		p01.send("This is a great stuff")
		p02.receive()
		
		p02.send("This is really nice")
		alt([
			[ p01.RECEIVE("This is really nice"),
				lambda: setverdict("pass"),
			],
			[ p01.RECEIVE("Something else"),
				lambda: setverdict("inconc")
			],
			[ p01.RECEIVE(),
				lambda: setverdict("fail")
			],
		])

		# Order does matter in case of multiple matched events
		p02.send(11)
		alt([
			[ p01.RECEIVE(greater_than(10)),
				lambda: setverdict("pass"),
			],
			[ p01.RECEIVE(greater_than(5)),
				lambda: setverdict("fail")
			],
		])
		
		# Port disconnection
		disconnect(p01, p02)
		p01.send("This is a great stuff")
		t = Timer(1.0)
		t.start()
		alt([
			[ p02.RECEIVE(),
				lambda: log("Unexpected message received on a disconnected port"),
				lambda: setverdict("fail"),
				lambda: t.stop()
			],
			[ t.TIMEOUT,
				lambda: log("OK, nothing received on a disconnected port"),
				lambda: setverdict("pass"),
			],
		])
		
		# Loopback connection
		connect(p01, p01)
		p01.send("Loopback connection")
		p01.receive("Loopback connection")
		
		log("End of testcase reached.")

class TC_SIMPLE_1TON(TestCase):
	def body(self):
		log("Testerman autotest: implicit MTC, multiple ptc, one to N connections, no tsi, no ptc behavior, timeout objects")
		
		# Let's create some PTCs
		ptc01 = self.create()
		ptc02 = self.create()
		
		# Let's connect some ports: p01 connected to p02 and p03
		p01 = self.mtc['port01']
		p02 = ptc01['port02']
		p03 = ptc02['port03']
		connect(p01, p02)
		connect(p01, p03)
		
		# When sending something through p03, only p01 receives it.
		p03.send("message to p01")
		alt([
			[ p02.RECEIVE(),
				lambda: log("received an unexpected message on p02"),
				lambda: setverdict("fail"),
				lambda: stop(),
			],
			[ p01.RECEIVE("message to p01"),
				lambda: setverdict("pass"),
			],
			[ p01.RECEIVE(),
				lambda: log("received an incorrect message on p01"),
				lambda: setverdict("fail"),
				lambda: stop(),
			],
		])
		
		# When sending something through p01, both p02 and p03 receives it.

		# Long version, with precise case to diagnose the problem		
		p01.send("message to p02+p03")
		timer = Timer(5.0)
		timer.start()
		alt([
			[ p02.RECEIVE("message to p02+p03"),
				lambda: alt([
					[ p02.RECEIVE(),
						lambda: log("Multiple messages received on p02"),
						lambda: setverdict("fail"),
					],
					[ p03.RECEIVE("message to p02+p03"),
						lambda: setverdict("pass"),
					],
					[ timer.TIMEOUT,
						lambda: log("Nothing received on p03"),
						lambda: setverdict("fail"),
					],
				])
			],
			[ p03.RECEIVE("message to p02+p03"),
				lambda: alt([
					[ p03.RECEIVE(),
						lambda: log("Multiple messages received on p03"),
						lambda: setverdict("fail"),
					],
					[ p02.RECEIVE("message to p02+p03"),
						lambda: setverdict("pass"),
					],
					[ timer.TIMEOUT,
						lambda: log("Nothing received on p02"),
						lambda: setverdict("fail"),
					],
				])
			],
			[ timer.TIMEOUT,
				lambda: log("Nothing received on any port"),
				lambda: setverdict("fail"),
			],
		])
		timer.stop()

		# Short version, no timeout watchdog. It worked once, so it should work once more.
		p01.send("message to p02+p03")
		p02.receive("message to p02+p03")
		p03.receive("message to p02+p03")
		
		log("End of testcase reached.")

class TC_SIMPLE_1TON_SUBSET(TestCase):
	def body(self):
		log("Testerman autotest: implicit MTC, multiple ptc, one to N connections")
		
		# Let's create some PTCs
		ptc01 = self.create(name = "PTC01")
		ptc02 = self.create(name = "PTC02")
		ptc03 = self.create(name = "PTC03")
		
		# Let's connect some ports: p01 connected to p02, p03, p04
		p01 = self.mtc['port']
		p02 = ptc01['port']
		p03 = ptc02['port']
		p04 = ptc03['port']
		connect(p01, p02)
		connect(p01, p03)
		connect(p01, p04)
	
		# Sending to a single component: p01 to p03 only
		p01.send("message to p03", ptc02)
		timer = Timer(1.0)
		timer.start()
		alt([
			[ p02.RECEIVE(),
				lambda: log("Received message on p02, failed"),
				lambda: setverdict("fail"),
			],
			[ p03.RECEIVE("message to p03"),
				lambda: alt([
					[ p03.RECEIVE(),
						lambda: log("Multiple messages received on p03"),
						lambda: setverdict("fail"),
					],
					[ p02.RECEIVE(),
						lambda: log("Received message on p02, failed"),
						lambda: setverdict("fail"),
					],
					[ p04.RECEIVE(),
						lambda: log("Received message on p04, failed"),
						lambda: setverdict("fail"),
					],
					[ timer.TIMEOUT,
						lambda: log("Nothing received on other ports - OK"),
					],
				])
			],
			[ p04.RECEIVE(),
				lambda: log("Received message on p04, failed"),
				lambda: setverdict("fail"),
			],
			[ timer.TIMEOUT,
				lambda: log("Nothing received on any port"),
				lambda: setverdict("fail"),
			],
		])
		timer.stop()

		# When sending something through p01 to ptc01, ptc02, so p04 (on ptc03) does not receive it

		p01.send("message to p02+p03", [ ptc01, ptc02 ])
		timer = Timer(1.0)
		timer.start()
		alt([
			[ p02.RECEIVE("message to p02+p03"),
				lambda: alt([
					[ p02.RECEIVE(),
						lambda: log("Multiple messages received on p02"),
						lambda: setverdict("fail"),
					],
					[ p03.RECEIVE("message to p02+p03"),
						lambda: setverdict("pass"),
					],
					[ p04.RECEIVE(),
						lambda: log("Received message on p04, failed"),
						lambda: setverdict("fail"),
					],
					[ timer.TIMEOUT,
						lambda: log("Nothing received on p03"),
						lambda: setverdict("fail"),
					],
				])
			],
			[ p03.RECEIVE("message to p02+p03"),
				lambda: alt([
					[ p03.RECEIVE(),
						lambda: log("Multiple messages received on p03"),
						lambda: setverdict("fail"),
					],
					[ p02.RECEIVE("message to p02+p03"),
						lambda: setverdict("pass"),
					],
					[ p04.RECEIVE(),
						lambda: log("Received message on p04, failed"),
						lambda: setverdict("fail"),
					],
					[ timer.TIMEOUT,
						lambda: log("Nothing received on p02"),
						lambda: setverdict("fail"),
					],
				])
			],
			[ p04.RECEIVE(),
				lambda: log("Received message on p04, failed"),
				lambda: setverdict("fail"),
			],
			[ timer.TIMEOUT,
				lambda: log("Nothing received on any port"),
				lambda: setverdict("fail"),
			],
		])
		timer.stop()
		
		log("End of testcase reached.")

class BEHAVIOUR_SIMPLE_PTC(Behaviour):
	def body(self):
		"""
		This is a sample behaviour for TC_SIMPLE_PTC
		"""
		# Get an aliases referenced to the ports that are assumed
		# to be connected
		
		# alternative: p02 = self.ptc['port02']
		p02 = self['port02']
		
		# The usual watchdog
		t = Timer(2.0, name = "watchdog")
		t.start()
		alt([
			[ p02.RECEIVE("ping"),
				lambda: p02.send("pong"),
			],
			[ t.TIMEOUT,
				lambda: log("timeout while waiting for a ping"),
				lambda: setverdict("fail")
			]
		])
		t.stop()

		log("This log was created from a parallel test component")
		
		# Let's create an articifial delay so that the ptc.done() must wait a little.
		# Note: timers are not interruptible with a ptc.stop() or kill().
		t = Timer(2.0)
		t.start()
		t.timeout()
		
		# PTC verdicts are taken into account to determine the final testcase verdict
		# Will only be set to pass if not already failed due to the watchdog timeout above
		setverdict("pass")

class TC_SIMPLE_PTC(TestCase):
	def body(self):
		log("Testerman autotest: PTC (ping replier)")
		
		# Let's define a PTC
		ptc01 = self.create(name = "Simple PTC")
		
		# Let's connect some ports
		p01 = self.mtc['port01']
		p02 = ptc01['port02']
		connect(p01, p02)
		
		# Let's start ptc01 with a simple sample behavior.
		# Note: it is dangerous to change the test configuration (i.e. the port connections) after starting PTCs.
		ptc01.start(BEHAVIOUR_SIMPLE_PTC())
		
		# Let's send a message through port 01. The Behavior_Sample3 is expected to echo the message, adding a final * to it.
		p01.send("ping")
		
		p01.receive("pong")

		# Let's wait for ptc01 to finish
		ptc01.done()

		# In this testcase, only the PTC behavior verdict can set the testcase verdict to pass. This is what we want to test.
		log("End of testcase reached.")


class BEHAVIOUR_ALIVE_NONALIVE(Behaviour):
	"""
	You may also add a description here, but it won't be reflected into execution
	logs (for now).
	Still convenient for self documentation.
	"""
	def body(self):
		p = self['port']

		alt([
			[ p.RECEIVE("This is a message"), # this is a comment
				lambda: stop() # stop the behavior/PTC (no need to put it here, just to show it off)
			],
			[ p.RECEIVE("This is an almost missed message"),
				lambda: setverdict("pass"), # ok, this is the missed message that can be received only on alive components.
			]
		])

		
class TC_ALIVE_AND_NONALIVE(TestCase):
	def body(self):
		log("Testerman autotest: alive and non-alive component")
		
		# Let's define a non-alive PTC (the default create() mechanism)
		# The PTC will be killed automatically once start(behavior()) is over on it.
		ptcNA = self.create(name = "ptc01, non alive")
		
		# Now, let's create an alive component
		ptcA = self.create(alive = True)

		# Let's connect some ports
		p01 = self.mtc['port01']
		p02 = self.mtc['port02']
		pA = ptcA['port']
		pNA = ptcNA['port']
		connect(p01, pA)
		connect(p02, pNA)
		
		# Let's start ptc01 with a simple sample behavior.
		# Note: it is dangerous to change the test configuration (i.e. the port connections) after starting PTCs.
		ptcNA.start(BEHAVIOUR_ALIVE_NONALIVE())
		p02.send("This is a message")
		ptcNA.done()
		# automatically killed
		if ptcNA.alive():
			setverdict("fail")
			log("non alive component not automatically killed")
			stop()
		else:
			log("ptcNA was killed")
		

		# on alive component, when stopped (explicitly or on done()) and then restarted with the same or a new behavior,
		# the port queues are unchanged. As a consequence, when restarting your new behavior, you may read
		# events that you 'missed' during the component inactivity.
		ptcA.start(BEHAVIOUR_ALIVE_NONALIVE())
		p01.send("This is a message")
		ptcA.done()
		if not ptcA.alive():
			setverdict("fail")
			log("alive component automatically killed")
			stop()
		
		p01.send("This is an almost missed message")
		
		ptcA.start(BEHAVIOUR_ALIVE_NONALIVE())
		# ptcA will receive the missed message
		ptcA.done()

		# The verdict is defined by the synthesis of all PTC verdicts + current testcase verdict (set to 'none' by default)		
		log("End of testcase reached.")

		# remaining PTCs are automatically stop()ed and kill()ed when the TestCase if finished.

class TC_VALUE_EXTRACTION(TestCase):
	def body(self):
		log("Testerman autotest: template matching and value extraction")

		p01 = self.mtc['port01']
		p02 = self.mtc['port02']
		connect(p01, p02)
		
		# The template match is performed with the new value() complete message extractor function.
		# This avoids to incorporate in templates extractors, which are context-dependent.
		p01.send( { 'field1': 'value1', 'field2': 'value2' } )
		alt([
			[ p02.RECEIVE({ 'field2': any() }, 'message'),
				lambda: log("Received message: " + str(value('message'))),
				lambda: log("Received message field: " + value('message')['field1']),
				lambda: setverdict("pass"),
			],
		])

		log("End of testcase reached.")

class TC_VALUE_EXTRACTION_SELECTIVE(TestCase):
	def body(self):
		log("Testerman autotest: template matching and selective value extraction")

		p01 = self.mtc['port01']
		p02 = self.mtc['port02']
		connect(p01, p02)
		
		# The template match is performed with the new value() complete message extractor function.
		# This avoids to incorporate in templates extractors, which are context-dependent.
		p01.send( { 'field1': 'value1', 'field2': 'value2',  'list': [ 1, 2, 3, 4, 5, 6, 7 ], 'number': 10 } )
		alt([
			[ p02.RECEIVE({ 'field2': any(), 'list': [ 1, extract(any(), 'sel_val_1'), 3, any_or_none() ], 'number': extract(greater_than(9), 'sel_val_2') }),
				lambda: log("Received selected value 1: %s " % value('sel_val_1')),
				lambda: log("Received selected value 2: %s " % value('sel_val_2')),
			],
			[ p02.RECEIVE(),
				lambda: setverdict("fail"),
			],
		])
		
		if value('sel_val_1') == 2 and value('sel_val_2') == 10:
			setverdict('pass')

		log("End of testcase reached.")

class TC_CODEC(TestCase):
	def body(self):
		log("Testerman autotest: simple codec management in templates")

		p01 = self.mtc['port01']
		p02 = self.mtc['port02']
		connect(p01, p02)
		
		template = { 'string': 'a string', 'unicode': u"comment Ã§a va ?", 'list': [1, 2, 3], 'tuple': ('choiceName', 'value') }
		
		template_codec = with_('pickle', template)

		# TODO: support for a codec anywhere in the struct, on only at start
		template = with_('pickle', { 'base64': with_('base64', 'hello'), 'no-encoding': 'yo' })

		p01.send(template)
		alt([
			[ p02.RECEIVE(template, 'message'),
				lambda: log("Received message: " + str(value('message'))),
				lambda: setverdict("pass"),
			],
			[ p02.RECEIVE(),
				lambda: log("Something else received."),
				lambda: setverdict("fail"),
			],
		])

		log("End of testcase reached.")

class TC_TEMPLATE_MATCH_GENERAL(TestCase):
	def body(self):
		log("Testerman autotest: template matching, general mechanisms")

		p01 = self.mtc['port01']
		p02 = self.mtc['port02']
		connect(p01, p02)
		
		def assert_match(message, template):
			res = StateManager(False)
			t = Timer(1.0)
			t.start()
			p01.send(message)
			alt([
				[ p02.RECEIVE(template),
					lambda: res.set(True)
				],
				[ p02.RECEIVE(),
				],
				[ t.TIMEOUT,
				],
			])
			t.stop()
			return res.get()
			
		try:
			# Unit testing: simple types
			if not assert_match('string', None): raise Exception('(all match)')
			if not assert_match('string', 'string'): raise Exception('string')
			if not assert_match(u'unicode', u'unicode'): raise Exception('unicode')
			if not assert_match(1234, 1234): raise Exception('integer')
			if not assert_match(1234.0, 1234.0): raise Exception('float')
			if not assert_match(True, True): raise Exception('bool')
			if not assert_match(False, False): raise Exception('bool')
			if not assert_match(('choiceName', 'value'), ('choiceName', 'value')): raise Exception('couple')
			if not assert_match([ 1, 2, 3, 4 ], [ 1, 2, 3, 4 ]): raise Exception('list/0')
			if not assert_match([ 1, 2, 3, 4 ], superset()): raise Exception('list/0')
			if not assert_match([ 1, 2, 3, 4 ], superset(2)): raise Exception('list/1')
			if not assert_match([ 1, 2, 3, 4 ], superset(1, 2)): raise Exception('list/2')
			if not assert_match([ 1, 2, 3, 4 ], superset(1, 2, 3, 4)): raise Exception('list/3')
			if not assert_match({ 'key1': 'value1' }, { }): raise Exception('dict/0')
			if not assert_match({ 'key1': 'value1' }, { 'key1': 'value1' }): raise Exception('dict/1')
			if not assert_match({ 'key0': 'value0', 'key1': 'value1' }, { 'key1': 'value1' }): raise Exception('dict/2')

			# Nested types
			message = { 'string': 'a string', 'unicode': u"comment ca va ?", 'list': [1, 2, 3], 'tuple': ('choiceName', 'value') }
			if not assert_match(message, message): raise Exception('recursive/0')
			if not assert_match(message, { 'list': superset(2) }): raise Exception('recursive/1')
			if not assert_match(message, { 'tuple': ('choiceName', 'value') }): raise Exception('recursive/2')
			
			message = ('choiceName', [ { 'key': [ ('choiceName2', { 'key2': 2.0 } ) ] }, { 'key4': [ ('choiceName2', { 'key2': 1.0 } ), ('choiceName3', { 'key2': 1.0 } ), ('choiceName4', { 'key2': 3.0 } ) ] } ])
			if not assert_match(message, message): raise Exception('recursive/3')
			if not assert_match(message, ('choiceName', superset({ 'key4': superset(('choiceName3', { 'key2': 1.0 }))}))): raise Exception('recursive/4')
	
			setverdict('pass')
		except Exception as e:
			log("Unable to complete test case: matching error for %s" % str(e))
			setverdict('fail')

		log("End of testcase reached.")

class TC_TEMPLATE_MATCH_LIST(TestCase):
	def body(self):
		log("Testerman autotest: template matching, list")

		p01 = self.mtc['port01']
		p02 = self.mtc['port02']
		connect(p01, p02)
		
		def assert_match(message, template):
			res = StateManager(False)
			t = Timer(1.0)
			t.start()
			p01.send(message)
			alt([
				[ p02.RECEIVE(template),
					lambda: res.set(True)
				],
				[ p02.RECEIVE(),
				],
				[ t.TIMEOUT,
				],
			])
			t.stop()
			return res.get()
			
		try:
			# Unit testing: simple types
			if not assert_match([], None): raise Exception('(none/0)')
			if not assert_match([], any_or_none()): raise Exception('(any_or_none/0)')
			# we should have a mismatch here: any() requires at least one element in list
			if assert_match([], any()): raise Exception('(any/0)')
			if not assert_match([1], None): raise Exception('(none/1)')
			if not assert_match([1], any_or_none()): raise Exception('(any_or_none/1)')
			if not assert_match([1], any()): raise Exception('(any/1)')

			if not assert_match([1, 2], [1, 2]): raise Exception('(ordered/1)')
			# order matters
			if assert_match([1, 2], [2, 1]): raise Exception('(ordered/2)')
			# wildcards
			if not assert_match([1, 2, 3], [1, any(), 3]): raise Exception('(wildcard/1)')
			if not assert_match([1, 2, 3], [1, any_or_none(), 3]): raise Exception('(wildcard/2)')
			# still verifying order
			if assert_match([1, 2, 3], [3, any(), 2]): raise Exception('(wildcard/3)')
			# wildcards *
			if not assert_match([1, 2, 3], [any_or_none(), 3]): raise Exception('(wildcard/4)')
			if assert_match([1, 2, 3], [any(), 3]): raise Exception('(wildcard/5)')
			if not assert_match([1, 2, 3], [1, 2, any_or_none()]): raise Exception('(wildcard/6)')
			if not assert_match([1, 2, 3], [any_or_none()]): raise Exception('(wildcard/7)')
			if not assert_match([1, 2, 3, 4], [1, any_or_none(), 4]): raise Exception('(wildcard/8)')
			if not assert_match([1, 3], [1, any_or_none(), 3]): raise Exception('(wildcard/10)')
			if not assert_match([1, 2, 3, 4, 5, 6, 7], [1, any_or_none(), 3, 4, any(), 6, 7]): raise Exception('(wildcard/9)')
			if not assert_match([1, 2, 3, 4, 5, 6, 7], [1, any_or_none(), 3, 4, any_or_none(), 7]): raise Exception('(wildcard/9)')
			if not assert_match([1, 2, 3, 4, 5, 6, 7], [1, any_or_none(), 3, 4, 5, 6, any_or_none(), 7]): raise Exception('(wildcard/9)')
			if not assert_match([1, 2, 3, 4, 5, 6, 7], [any_or_none(), any_or_none(), 7]): raise Exception('(wildcard/9)')
			if not assert_match([1, 2, 3, 4, 5, 6, 7], [any_or_none(), 5, any_or_none()]): raise Exception('(wildcard/9)')
			if not assert_match([1, 2, 3, 4, 5, 6, 7], [1, any_or_none(), any_or_none()]): raise Exception('(wildcard/9)')
			if not assert_match([1, 2, 3, 4, 5, 6, 7], [any_or_none(), any_or_none()]): raise Exception('(wildcard/9)')
			if not assert_match([1, 2, 3, 4, 5, 6, 7], [any_or_none(), 1, any_or_none()]): raise Exception('(wildcard/9)')
			if assert_match([1, 2, 3, 4, 5, 6, 7], [1, any_or_none(), 1, any_or_none()]): raise Exception('(wildcard/9)')

			setverdict('pass')
		except Exception as e:
			log("Unable to complete test case: matching error for %s" % str(e))
			setverdict('fail')

class TC_TEMPLATE_WILDCARDS_CONTAINS(TestCase):
	def body(self):
		log("Testerman autotest: contains() wildcard, including nested conditions")
		
		p01 = self.mtc['port1']
		p02 = self.mtc['port2']
		
		connect(p01, p02)
		
		element1 = { 'name': 'element1', 'value': 123 }
		element2 = { 'name': 'element2', 'value': 434 }
		element3 = { 'name': 'element3', 'value': 123 }
		element4 = { 'name': 'element3', 'value': 1000 }

		# Basic matching
		p01.send([ element1, element2, element3 ])
		alt([
			[ p02.RECEIVE(contains( element3 )),
				lambda: log("basic matching OK"),
			],
			[ p02.RECEIVE(),
				lambda: setverdict('fail'),
			],
		])

		# Basic mistmatching
		p01.send([ element1, element2, element3 ])
		alt([
			[ p02.RECEIVE(contains( element4 )),
				lambda: setverdict('fail'),
			],
			[ p02.RECEIVE(),
				lambda: log("basic mismatching OK"),
			],
		])

		# Netsted conditions, matching
		p01.send([ element1, element2, element3, element4 ])
		alt([
			[ p02.RECEIVE(contains( { 'value': greater_than(500) } )),
				lambda: log("nested conditions matching OK"),
			],
			[ p02.RECEIVE(),
				lambda: setverdict('fail'),
			],
		])

		# Neted conditions, mismatching
		p01.send([ element1, element2, element3, element4 ])
		alt([
			[ p02.RECEIVE(contains( { 'value': greater_than(1500) } )),
				lambda: setverdict('fail'),
			],
			[ p02.RECEIVE(),
				lambda: log("nested conditions mismatching OK"),
			],
		])

		setverdict('pass')
		log("End of testcase reached.")

class TC_TEMPLATE_WILDCARDS_LENGTH(TestCase):
	"""
	Typical length() usages, i.e. including sub-scalar conditions.
	"""
	def body(self):
		log("Testerman autotest: length() wildcard, including nested conditions")
		
		p01 = self.mtc['port1']
		p02 = self.mtc['port2']
		
		connect(p01, p02)
		
		# Length Equality: matching
		p01.send([ 1, 2, 3, 4 ])
		alt([
			[ p02.RECEIVE(length(4)),
				lambda: log("basic matching OK"),
			],
			[ p02.RECEIVE(),
				lambda: setverdict('fail'),
			],
		])

		# Length Equality: mismatching
		p01.send([ 1, 2, 3, 4 ])
		alt([
			[ p02.RECEIVE(length(3)),
				lambda: setverdict('fail'),
			],
			[ p02.RECEIVE(),
				lambda: log("basic mismatching OK"),
			],
		])

		# Length greater than: matching
		p01.send([ 1, 2, 3, 4 ])
		alt([
			[ p02.RECEIVE(length(greater_than(3))),
				lambda: log("greater than matching OK"),
			],
			[ p02.RECEIVE(),
				lambda: setverdict('fail'),
			],
		])

		# Length greater than: mismatching
		p01.send([ 1, 2, 3, 4 ])
		alt([
			[ p02.RECEIVE(length(greater_than(5))),
				lambda: setverdict('fail'),
			],
			[ p02.RECEIVE(),
				lambda: log("greater than mismatching OK"),
			],
		])

		# Length lower than: matching
		p01.send([ 1, 2, 3, 4 ])
		alt([
			[ p02.RECEIVE(length(lower_than(10))),
				lambda: log("lower than matching OK"),
			],
			[ p02.RECEIVE(),
				lambda: setverdict('fail'),
			],
		])

		# Length lower than: mismatching
		p01.send([ 1, 2, 3, 4 ])
		alt([
			[ p02.RECEIVE(length(lower_than(3))),
				lambda: setverdict('fail'),
			],
			[ p02.RECEIVE(),
				lambda: log("lower than mismatching OK"),
			],
		])

		# Length between: matching
		p01.send([ 1, 2, 3, 4 ])
		alt([
			[ p02.RECEIVE(length(between(3, 6))),
				lambda: log("between matching OK"),
			],
			[ p02.RECEIVE(),
				lambda: setverdict('fail'),
			],
		])

		# Length between: mismatching
		p01.send([ 1, 2, 3, 4 ])
		alt([
			[ p02.RECEIVE(length(between(1, 3))),
				lambda: setverdict('fail'),
			],
			[ p02.RECEIVE(),
				lambda: log("between mismatching OK"),
			],
		])
		setverdict('pass')
		log("End of testcase reached.")

class TC_TEMPLATE_WILDCARDS_NOT(TestCase):
	"""
	Several not_() usages.
	"""
	def body(self):
		log("Testerman autotest: not_() wildcard, with nested conditions")
		
		p01 = self.mtc['port1']
		p02 = self.mtc['port2']
		
		connect(p01, p02)
		
		# Basic not matching
		p01.send(10)
		alt([
			[ p02.RECEIVE(not_(9)),
				lambda: log("not matching OK"),
			],
			[ p02.RECEIVE(),
				lambda: setverdict('fail'),
			],
		])
		
		# Basic not mistmatching
		p01.send(10)
		alt([
			[ p02.RECEIVE(not_(10)),
				lambda: setverdict('fail'),
			],
			[ p02.RECEIVE(),
				lambda: log("not mismatching OK"),
			],
		])

		# length negation: matching
		p01.send([ 1, 2, 3, 4 ])
		alt([
			[ p02.RECEIVE(not_(length(between(1, 3)))),
				lambda: log("between matching OK"),
			],
			[ p02.RECEIVE(),
				lambda: setverdict('fail'),
			],
		])

		# length negation: mismatching
		p01.send([ 1, 2, 3, 4 ])
		alt([
			[ p02.RECEIVE(not_(length(between(1, 10)))),
				lambda: setverdict('fail'),
			],
			[ p02.RECEIVE(),
				lambda: log("between mismatching OK"),
			],
		])

		setverdict('pass')
		log("End of testcase reached.")

class TC_TEMPLATE_WILDCARDS_OMIT(TestCase):
	"""
	Basic omit() verification
	"""
	def body(self):
		log("Testerman autotest: omit() wildcard")
		
		p01 = self.mtc['port1']
		p02 = self.mtc['port2']
		
		connect(p01, p02)
		
		# Basic not matching
		p01.send({ 'f1': 'value1', 'f2': 'value2' })
		alt([
			[ p02.RECEIVE({ 'f1': 'value1', 'f3': omit() }),
				lambda: log("omit matching OK"),
			],
			[ p02.RECEIVE(),
				lambda: setverdict('fail'),
			],
		])
		
		# Basic not mistmatching
		p01.send({ 'f1': 'value1', 'f2': 'value2' })
		alt([
			[ p02.RECEIVE({ 'f1': 'value1', 'f2': omit() }),
				lambda: setverdict('fail'),
			],
			[ p02.RECEIVE(),
				lambda: log("omit mismatching OK"),
			],
		])
		setverdict('pass')

class TC_TEMPLATE_WILDCARDS_VALUE(TestCase):
	"""
	Verifies that we can send the same template containing
	between/lower_than/greater_than in both receiving and sending.
	between() enables random values generation.
	"""
	def body(self):
		log("Starting basic condition valuation tests...")
		p01 = self.mtc['port1']
		p02 = self.mtc['port2']
		connect(p01, p02)
		
		mw_template = { 'between': between(0, 10), 'greater': greater_than(4), 'lower': lower_than(5) }
		t = Timer(name = "watchdog", duration = 1.0)
		t.start()
		p01.send(mw_template)
		alt([
			[ p02.RECEIVE(mw_template),
				lambda: setverdict('pass'),
			],
			[ p02.RECEIVE(),
				lambda: setverdict('fail'),
			],
			[ t.TIMEOUT,
				lambda: setverdict('fail'),
			],
		])

class TC_UNICODE(TestCase):
	"""
	Verifies that we can send unicode strings (and log them correctly).
	"""
	def body(self):
		log("Starting unicode support in ATS...")
		
		p01 = self.mtc['port1']
		p02 = self.mtc['port2']
		
		connect(p01, p02)
		
		element1 = { 'name': u'Ã©lÃ©ment', 'value': 123 }

		log(u"User log: sending Ã©lÃ©ment")

		p01.send(element1)
		alt([
			[ p02.RECEIVE(element1),
			],
			[ p02.RECEIVE(None),
				lambda: setverdict('fail'),
				lambda: stop()
			],
		])
		setverdict('pass')

		log("End of testcase reached.")

class TC_UNICODE_SESSION_PARAMETERS(TestCase):
	"""
	Verifies that the user can set unicode parameters in session parameters.
	"""
	def body(self):
		log("Starting unicode support from Session...")
		
		p01 = self.mtc['port1']
		p02 = self.mtc['port2']
		
		connect(p01, p02)
		
		log("User log: sending %s" % get_variable('PX_UNICODE_STRING'))
		
		element1 = { 'name': get_variable('PX_UNICODE_STRING') }

		# Complete matching
		p01.send(element1)
		alt([
			[ p02.RECEIVE({ 'name': u'Ã§a marche' }),
			],
			[ p02.RECEIVE(None),
				lambda: setverdict('fail'),
				lambda: stop()
			],
		])
		setverdict('pass')

		log("End of testcase reached.")

class TC_BINARY_LOGGING(TestCase):
	"""
	Verifies that we can send binary payload - should
	not lead to an exception when generating associated logs.
	"""
	def body(self):
		p01 = self.mtc['port1']
		p02 = self.mtc['port2']
		
		connect(p01, p02)
		
		element1 = { 'binary-value': '\x12\xff\x00' }
		
		log("Sending some binarany data: %s" % element1)

		p01.send(element1)
		alt([
			[ p02.RECEIVE({ 'binary-value': octetstring('12ff00')}),
			],
			[ p02.RECEIVE(),
				lambda: setverdict('fail'),
				lambda: stop()
			],
		])
		setverdict('pass')

		log("End of testcase reached.")

class BEHAVIOUR_LOOP(Behaviour):
	"""
	A looping behaviour, used to test stop(), kill() ptc methods.
	"""
	def body(self):
		control = self['control']
		alt([
			[ control.RECEIVE(),
				lambda: log('Received an event on control port. Gracefully stopping...')
			]
		])
		setverdict('pass')

class TC_STOP_PTC_DONE_EVENT(TestCase):
	"""
	Verifies that a running PTC, when stopped, emits a DONE event.
	"""
	def body(self):
		ptc = self.create('Looping ptc')
		control = ptc['control']
		connect(control, control)
		ptc.start(BEHAVIOUR_LOOP())
		
		# Graceful stop
		control.send("It's time to stop")
		t = Timer(1.0)
		t.start()
		alt([
			[ ptc.DONE,
				lambda: log("PTC gracefully stopped, signal received.")
			],	
			[ t.TIMEOUT,
				lambda: log("PTC not stopped as expected (no signal received)"),
				lambda: setverdict("fail"),
				lambda: stop(),
			]
		])
		t.stop()
		# Verdict from PTC
		
class TC_STOP_PTC_DONE(TestCase):
	"""
	Verifies that a ptc.done() operation works correctly.
	Blocks if not...
	"""
	def body(self):
		ptc = self.create('Looping ptc')
		control = ptc['control']
		connect(control, control)
		ptc.start(BEHAVIOUR_LOOP())
		
		# Graceful stop
		control.send("It's time to stop")
		ptc.done()
		# Verdict from PTC

class TC_STOP_PTC_STOP(TestCase):
	"""
	Verifies that a running PTC with an infinite alt can be stopped from outside (explicit ptc.stop())
	"""
	def body(self):
		ptc = self.create('Looping ptc')
		control = ptc['control']
		connect(control, control)
		ptc.start(BEHAVIOUR_LOOP())
	
		ptc.stop()
		
		ptc.done()
		# Normally we get the Verdict from PTC - the last known verdict,
		# which is probably none when stopping a PTC from outside (but not necessarely)
		setverdict('pass')

class TC_STOP_PTC_STOP_TESTCASE(TestCase):
	"""
	Verifies that a running PTC with an infinite alt can be stopped when stopping the testcase (implicit stop)
	
	Note that this testcase is either pass, or never returns. So no "fail" is possible for it.
	"""
	def body(self):
		ptc = self.create('Looping ptc')
		control = ptc['control']
		connect(control, control)
		ptc.start(BEHAVIOUR_LOOP())

		setverdict('pass')
		# We don't wait for the ptc completion. We stop the testcase.
		stop()

class TC_KILL_PTC_KILLED_EVENT(TestCase):
	"""
	Verifies that a running PTC, when stopped, emits a KILLED event.
	"""
	def body(self):
		ptc = self.create('Looping ptc')
		control = ptc['control']
		connect(control, control)
		ptc.start(BEHAVIOUR_LOOP())
		
		# Graceful stop
		ptc.kill()
		t = Timer(1.0)
		t.start()
		alt([
			[ ptc.KILLED,
				lambda: log("PTC killed, signal received.")
			],	
			[ t.TIMEOUT,
				lambda: log("PTC not stopped as expected (no signal received)"),
				lambda: setverdict("fail"),
				lambda: stop(),
			]
		])
		t.stop()
		setverdict('pass')

class TC_KILL_PTC_DONE_EVENT(TestCase):
	"""
	Verifies that a running PTC, when stopped, emits a DONE event.
	"""
	def body(self):
		ptc = self.create('Looping ptc')
		control = ptc['control']
		connect(control, control)
		ptc.start(BEHAVIOUR_LOOP())
		
		# Graceful stop
		ptc.kill()
		t = Timer(1.0)
		t.start()
		alt([
			[ ptc.DONE,
				lambda: log("PTC killed, done signal received.")
			],	
			[ t.TIMEOUT,
				lambda: log("PTC not killed as expected (no signal received)"),
				lambda: setverdict("fail"),
				lambda: stop(),
			]
		])
		t.stop()
		setverdict('pass')

class TC_KILL_PTC_DONE(TestCase):
	"""
	Verifies that a ptc.done() operation works correctly after a kill() op.
	This test is actually useless: TC_KILL_PTC_DONE_EVENT tests it, too.
	"""
	def body(self):
		ptc = self.create('Looping ptc')
		control = ptc['control']
		connect(control, control)
		ptc.start(BEHAVIOUR_LOOP())

		ptc.kill()
		ptc.done()
		setverdict('pass')

class TC_ACTION(TestCase):
	"""
	Verifies that calling action() with timeout works.
	"""
	def body(self):
		t = Timer(7.0)
		t.start()
		action("If you see me, click me", timeout = 5.0)
		duration = t.read()
		t.stop()
		delta = 0.200 # 200ms of tolerance
		if duration > (5.0 + delta):
			log("Too long to perform action (implictly or not)")
			self.setverdict('fail')
		else:
			self.setverdict('pass')

class TC_ACTIVATE(TestCase):
	"""
	Verifies the activate/deactivate on default altsteps.
	"""
	def body(self):
		port = self.mtc['port']
		defaultTimer = Timer(name = "default", duration = 0.5)
		t = Timer(name = "watchdog", duration = 1.0)
		
		def altstep_timer():
			return [
				[ defaultTimer.TIMEOUT,
					lambda: setverdict('pass')
				]
			]
		
		activate(altstep_timer())
		defaultTimer.start()
		t.start()
		
		alt([
			[ port.RECEIVE(),
				lambda: log("oops, received something on an idle port"),
				lambda: setverdict('fail'),
				lambda: stop(),
			],
			[ t.TIMEOUT,
				lambda: log("The watchdog timer expired; the default one should have expired before it"),
				lambda: setverdict('fail'),
				lambda: stop(),
			]
		])
		
class TC_DEACTIVATE(TestCase):
	"""
	Verifies the activate/deactivate on default altsteps.
	"""
	def body(self):
		port = self.mtc['port']
		defaultTimer = Timer(name = "default", duration = 0.5)
		t = Timer(name = "watchdog", duration = 1.0)
		
		def altstep_timer():
			return [
				[ defaultTimer.TIMEOUT,
					lambda: setverdict('fail')
				]
			]
		
		# Has been tested OK (normally)
		default_altstep = activate(altstep_timer())
		
		# Now, deactivate it
		deactivate(default_altstep)
		defaultTimer.start()
		t.start()

		alt([
			[ port.RECEIVE(),
				lambda: log("oops, received something on an idle port"),
				lambda: setverdict('fail'),
				lambda: stop(),
			],
			[ t.TIMEOUT,
				lambda: log("The watchdog timer expired, not hidden by the default altstep"),
				lambda: setverdict('pass'),
			]
		])


class TC_ALL_COMPONENT_DONE_EVENT(TestCase):
	"""
	Verifies that 'all component.done' Testerman implementation basically works (in a alt)
	"""
	def body(self):
		control = self.mtc['control']
		
		nb = 5
		# Creates N PTCs whose control port is connected to the main control
		log("Creating and starting all PTCs...")
		for i in range(nb):
			ptc = self.create('tc %s' % i)
			connect(control, ptc['control'])
			ptc.start(BEHAVIOUR_LOOP())
		
		log("Gracefully stopping all PTCs...")
		control.send("please stop") # 1 -> N PTCs
		log("Waiting for PTCs completions...")

		# Graceful stop
		t = Timer(1.0)
		t.start()
		alt([
			[ all_component.DONE,
				lambda: log("all PTC stopped.")
			],
			[ t.TIMEOUT,
				lambda: log("all PTC stopped event not detected"),
				lambda: setverdict("fail"),
				lambda: stop(),
			]
		])
		t.stop()
		# Verdict from PTC (gracefully stopped)

class TC_ALL_COMPONENT_DONE_EVENT_2(TestCase):
	"""
	Verifies that 'all component.done' Testerman implementation basically works (in a alt)
	
	Includes a negative test, verifying that the event is not fired too soon.
	"""
	def body(self):
		control = self.mtc['control']
		
		nb = 5
		ptcs = []
		# Creates N PTCs whose control port is connected to the main control
		log("Creating and starting all PTCs...")
		for i in range(nb):
			ptc = self.create('tc %s' % i)
			connect(control, ptc['control'])
			ptc.start(BEHAVIOUR_LOOP())
			ptcs.append(ptc)
		
		log("Stopping some PTCs...")
		for ptc in ptcs[:-1]:
			ptc.stop()

		log("Verifying that no all_component.DONE is received")

		t = Timer(1.0)
		t.start()
		alt([
			[ all_component.DONE,
				lambda: log("all PTC stopped incorrectly detected !"),
				lambda: setverdict("fail"),
				lambda: stop(),
			],
			[ t.TIMEOUT,
				lambda: log("all PTC stopped event not detected - OK"),
			]
		])
		t.stop()
		
		log("Stopping the last PTC...")
		ptcs[-1].stop()

		log("Expecting a all_component.DONE event...")
		t = Timer(1.0)
		t.start()
		alt([
			[ all_component.DONE,
				lambda: log("all PTC stopped.")
			],
			[ t.TIMEOUT,
				lambda: log("all PTC stopped event not detected"),
				lambda: setverdict("fail"),
				lambda: stop(),
			]
		])
		t.stop()
		setverdict('pass')

class TC_ALL_COMPONENT_DONE(TestCase):
	"""
	Verifies that 'all component.done' Testerman implementation basically works.
	"""
	def body(self):
		control = self.mtc['control']
		
		nb = 5
		# Creates N PTCs whose control port is connected to the main control
		log("Creating and starting all PTCs...")
		for i in range(nb):
			ptc = self.create('tc %s' % i)
			connect(control, ptc['control'])
			ptc.start(BEHAVIOUR_LOOP())
		
		log("Gracefully stopping all PTCs...")
		control.send("please stop") # 1 -> N PTCs
		log("Wait for PTCs completions...")
		
		all_component.done()
		# Verdict from PTC (gracefully stopped)

class TC_ALL_COMPONENT_STOP(TestCase):
	"""
	Verifies that 'all component.stop' Testerman implementation basically works.
	"""
	def body(self):
		nb = 5
		# Creates N PTCs whose control port is connected to the main control
		log("Creating and starting all PTCs...")
		for i in range(nb):
			ptc = self.create('tc %s' % i)
			ptc.start(BEHAVIOUR_LOOP())
		
		log("Stopping all PTCs...")
		all_component.stop()
		log("Wait for PTCs completions...")
		
		all_component.done()
		setverdict('pass')

class TC_ANY_COMPONENT_DONE_EVENT(TestCase):
	"""
	Verifies that 'any component.done' Testerman implementation basically works (in a alt)
	
	Includes a negative test, verifying that the event is not fired too soon.
	"""
	def body(self):
		control = self.mtc['control']
		
		nb = 5
		ptcs = []
		# Creates N PTCs whose control port is connected to the main control
		log("Creating and starting all PTCs...")
		for i in range(nb):
			ptc = self.create('tc %s' % i)
			connect(control, ptc['control'])
			ptc.start(BEHAVIOUR_LOOP())
			ptcs.append(ptc)
		
		log("Verifying that no any_component.DONE is received")

		t = Timer(1.0)
		t.start()
		alt([
			[ any_component.DONE,
				lambda: log("any PTC stopped incorrectly detected !"),
				lambda: setverdict("fail"),
				lambda: stop(),
			],
			[ t.TIMEOUT,
				lambda: log("any PTC stopped event not detected - OK"),
			]
		])
		t.stop()

		log("Stopping one PTC...")
		ptcs[2].stop()

		log("Expecting a any_component.DONE event...")
		t = Timer(1.0)
		t.start()
		alt([
			[ any_component.DONE,
				lambda: log("any PTC stopped.")
			],
			[ t.TIMEOUT,
				lambda: log("any PTC stopped event not detected"),
				lambda: setverdict("fail"),
				lambda: stop(),
			]
		])
		t.stop()
		setverdict('pass')
		# Stops all running PTC.
		stop()

class TC_ANY_COMPONENT_DONE(TestCase):
	"""
	Verifies that 'any component.done' Testerman implementation basically works (in a alt)
	
	Includes a negative test, verifying that the event is not fired too soon.
	"""
	def body(self):
		control = self.mtc['control']
		
		nb = 5
		ptcs = []
		# Creates N PTCs whose control port is connected to the main control
		log("Creating and starting all PTCs...")
		for i in range(nb):
			ptc = self.create('tc %s' % i)
			connect(control, ptc['control'])
			ptc.start(BEHAVIOUR_LOOP())
			ptcs.append(ptc)
		
		log("Stopping only one PTC...")
		ptcs[2].stop()

		any_component.done()
		setverdict('pass')
		# Stops all running PTC.
		stop()

##
# Control definition
##

TC_TIMER("Testerman autotest: timer management").execute()
TC_SIMPLE_CONNECTION("Testerman autotest: basic").execute()
TC_SIMPLE_1TON("Testerman autotest: 1 to N connections").execute()
TC_SIMPLE_1TON_SUBSET("Testerman autotest: 1 to N connections, sending to selected components").execute()
TC_SIMPLE_PTC("Testerman autotest: PTC behavior").execute()
TC_ALIVE_AND_NONALIVE("Testerman autotest: alive vs non-alive test component").execute()
TC_VALUE_EXTRACTION("Testerman autotest: template matching with extraction").execute()
TC_VALUE_EXTRACTION_SELECTIVE("Testerman autotest: template matching with selective extraction").execute()
TC_CODEC("Testerman autotest: simple codec management in templates").execute()

TC_TEMPLATE_MATCH_GENERAL("Testerman autotest: template matching").execute()
TC_TEMPLATE_MATCH_LIST("Testerman autotest: list matching").execute()
TC_TEMPLATE_WILDCARDS_CONTAINS("Testerman autotest: contains() matching mechanism").execute()
TC_TEMPLATE_WILDCARDS_LENGTH("Testerman autotest: length() matching mechanism").execute()
TC_TEMPLATE_WILDCARDS_NOT("Testerman autotest: not_() matching mechanism").execute()
TC_TEMPLATE_WILDCARDS_OMIT("Testerman autotest: omit() matching mechanism").execute()
TC_TEMPLATE_WILDCARDS_VALUE("Testerman autotest: simple matching mechanisms valuations").execute()

TC_UNICODE("Testerman autotest: unicode support in messages (+ logs)").execute()
TC_UNICODE_SESSION_PARAMETERS("Testerman autotest: unicode support in session parameters").execute()
TC_BINARY_LOGGING("Testerman autotest: binary support in messages (+ logs)").execute()

TC_STOP_PTC_DONE_EVENT().execute()
TC_STOP_PTC_DONE().execute()
TC_STOP_PTC_STOP().execute()
TC_STOP_PTC_STOP_TESTCASE().execute()
TC_KILL_PTC_DONE_EVENT().execute()
TC_KILL_PTC_KILLED_EVENT().execute()
TC_KILL_PTC_DONE().execute()

TC_ACTION().execute()

TC_ACTIVATE().execute()
TC_DEACTIVATE().execute()

TC_ALL_COMPONENT_DONE_EVENT().execute()
TC_ALL_COMPONENT_DONE_EVENT_2().execute()
TC_ALL_COMPONENT_DONE().execute()
TC_ALL_COMPONENT_STOP().execute()

TC_ANY_COMPONENT_DONE_EVENT().execute()
TC_ANY_COMPONENT_DONE().execute()
